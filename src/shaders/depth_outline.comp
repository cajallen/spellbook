#version 450
#pragma shader_stage(compute)

#include "include.glsli"

// compositing
layout(binding = 0) uniform sampler2D s_color;
layout(binding = 1) uniform sampler2D s_normal;
layout(binding = 2) uniform sampler2D s_depth;
layout(binding = 3) uniform sampler2D s_widget;
layout(binding = 4) uniform sampler2D s_widget_depth;
layout(binding = 5, rgba16f) uniform writeonly image2D u_target;

layout(constant_id = 0) const int target_width	= 0;
layout(constant_id = 1) const int target_height = 0;

layout(push_constant) uniform uPushConstant {
	vec4 outline_step;
} pc;


const int NUM_TAPS = 12;
const ivec3 samples[NUM_TAPS] = ivec3[](
    ivec3(-1, 0, 4),
    ivec3( 1, 0, 4),
    ivec3( 0,-1, 4),
    ivec3( 0, 1, 4),

    ivec3(-1,-1, 2),
    ivec3( 1, 1, 2),
    ivec3(-1, 1, 2),
    ivec3( 1,-1, 2),

    ivec3(-2, 0, 1),
    ivec3( 2, 0, 1),
    ivec3( 0,-2, 1),
    ivec3( 0, 2, 1)
);

float compare_depth(ivec2 coordinate, float depth) {
    vec4 depth_read = texelFetch(s_depth, coordinate, 0);
    if (depth_read.a < 0.1 || depth_read.r < 0.0001)
        depth_read = vec4(vec3(0.0001), 1.0);
    
    float other_depth = depth_read.r;
    other_depth = 1.0 / other_depth;

    float delta = abs(depth - other_depth);
    return delta;
}

float compare_normal(ivec2 coordinate, vec4 normal, float depth) {
    vec4 depth_read = texelFetch(s_depth, coordinate, 0);
    vec4 normal_read = texelFetch(s_normal, coordinate, 0);
    if (normal_read.a == 0.0)
        return 0.0;
    
    float other_depth = 1.0 / depth_read.r;
    float depth_delta = smoothstep(5.0, 10.0, abs(depth - other_depth));
    float depth_falloff = 1.0 - depth_delta;

    vec3 other_normal = normalize(normal_read.xyz);
    float normal_cont = depth_falloff * 5.0 * smoothstep(pc.outline_step.z, pc.outline_step.w, 1.0 - abs(dot(normal.xyz, other_normal)));

    return normal_cont;
}



layout (local_size_x = 8, local_size_y = 8) in;
void main() {
    ivec2 uv = ivec2(gl_GlobalInvocationID.xy);
	
    vec4 color = texelFetch(s_color, uv, 0);

    vec4 depth_read = texelFetch(s_depth, uv, 0);
    vec4 normal_read = texelFetch(s_normal, uv, 0);
    if (depth_read.a < 0.1 || depth_read.r < 0.0001)
        depth_read = vec4(vec3(0.0001), 1.0);

	vec4 normal = vec4(normalize(normal_read.xyz), normal_read.a);
    float depth = 1.0 / depth_read.r;

    float depth_outline = 0.0;
    float normal_outline = 0.0;
    for (int i = 0; i < NUM_TAPS; i++) {
        float depth_val = compare_depth(uv + samples[i].xy, depth);
        depth_outline += samples[i].z / 28.0 * depth_val;
    }
    depth_outline = smoothstep(pc.outline_step.x, pc.outline_step.y, depth_outline);
    
    if (normal.a != 0.0) {
        for (int i = 0; i < NUM_TAPS; i++) {
            normal_outline += samples[i].z / 28.0 * compare_normal(uv + samples[i].xy, normal, depth);
        }
    }
    float outline = max(depth_outline, normal_outline);

    color.rgb = mix(color.rgb, vec3(0.0), outline);

    vec4 widget_color = texelFetch(s_widget, uv, 0);
    vec4 widget_depth_read = texelFetch(s_widget_depth, uv, 0);
    float widget_depth = 1.0 / widget_depth_read.r;
    
    if (widget_color.a > 0.0) {
        if (widget_depth < depth)
            color.rgb = mix(color.rgb, widget_color.rgb, widget_color.a);
        else {
            if ((uv.x % 2 == 0) && (uv.y % 2 == 0))
                color.rgb = mix(color.rgb, widget_color.rgb, 0.5 * widget_color.a);
        }
    }
    
	color = vec4(linear_to_srgb(color.rgb), 1.0);
    imageStore(u_target, uv, color);
}